# LC203移除链表元素
## 题目链接[LeetCode](https://leetcode.cn/problems/remove-linked-list-elements/)
## 题目描述
给你一个链表的头节点`head`和一个整数`val`，请你删除链表中所有满足`Node.val == val`的节点，并返回**新的头节点**。
## 示例
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
## 解题思路
 - **虚拟头节点(dummy head)技巧**：链表头结点可能就是要删除的目标值，因此引入一个虚拟头节点指向原始头节点，这样即使头节点需要被删除，也能用统一逻辑处理。
 - 遍历列表：使用current指针遍历链表，检查current.next是否为目标值，如果是则删除，不是则正常向后移动。
 - 最后返回dummy.next
## 代码实现
见`LC203_remove_linked_list_elements/solution.py`
## 知识总结
 - 虚拟头节点：解决删除头节点的特殊情况，一般写法dummy=ListNode(0,head)。
    - ListNode(0):创建一个节点，值是0，next=None。这个节点目前是"**单独**"的，还没有和链表连起来。
    - ListNode(0,head):创建一个节点，值是0，next=head，这个节点一创造出来就和原链表连在一起，成为"虚拟头节点"。其作用是将链表的头结点当作"普通节点"来处理，删除头节点时也能用统一逻辑。
    - ListCode(next=head):等价于ListNode(0,head),val不写默认为0，next=head表示新节点的next指针指向链表的头节点head。
 - python中点号.表示**访问对象的属性或方法**，而下划线没有意义，除非自己手动定义了一个变量叫做这个名字。
    - e.g.:cur.next:下一个节点(类型还是ListNode)。
    - e.g.:cur.next.val:下一个节点存的值。
 - **链表**:
    - 链表是一种线性数据结构，其元素分散存放，每个节点通过"指针"链接起来。
    - **链表由一系列节点(Node)组成**，每个节点有两个部分：数据域(val,存放数据)和指针域(next,存放下一个节点的地址)
    - 链表在python中一般这样定义:
      class ListNode
          def __init__(self, val=0, next=None):
              self.val = val
              self.next = next
      e.g. head -> [1|next] -> [2|next] -> [3|next] -> None
            #head指向链表的第一个节点。[1|next]是一个节点，1是节点存的数据，next是指向下一个节点的指针。箭头 -> 是next指针的方向。None是链表最后一个节点的next的指向，表示链表到头了。
    - 链表的特点
       - 优点:插入、删除节点方便，只需要修改指针即可(O(1))。不需要连续内存，动态扩展性强。
       - 缺点:不能像数组那样用下标访问，只能从头一个一个找O((n))。需要额外的储存空间来保存指针。
    - 常见链表类型:
       - 单链表(最常见):每个节点只有一个next指针。
       - 双链表:每个节点有next和prev，可以双向遍历。
       - 循环链表:最后一个节点指向头节点，形成一个环。
    - 链表在内存中分散存放，不需要挨在一起，每个节点都保存了"下一个节点的地址"(即next指针),靠指针把所有节点串起来。即**链表物理上不一定连续，但逻辑上连续**。
      e.g.[10|next] 在地址 `0×100`
          [20|next] 在地址 `0×2F8`
          [30|NEXT] 在地址 `0×ABC`     #从地址上易得出，节点不是挨着的，但因为有next所以仍能一条一条走下去。(数组物理上和逻辑上都是连续的)
