# LC206反转链表
## 题目链接
[LeetCode](https://leetcode.cn/problems/reverse-linked-list/)
## 题目描述
给你单链表的头节点`head`，请你反转链表，并返回反转后的链表。
## 示例
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
## 解题思路
 - `head`前面命令一个`pre`值为`none`,使得在反转链表之后，从首变为尾的`head`后面可以接`null`(链表的结尾都应有)。
 - 命令第三个变量为`temp`,用`temp`去做衔接。
 - `reverselist`：对外的核心入口方法，负责接收题目给的链表头节点，执行反转逻辑，最后返回反转后的新节点。
 - 当当前节点`cur`运动到为空时，循环终止，此时头节点为`pre`
## 代码实现
见`LC206_reverse_linked_list/solution.py`
## 知识总结
 - 递归方法：**`reverse(cur,pre)`**:当前节点`cur`反转后要指向的那个前驱节点`pre`(`pre`在每一次递归时都会进行更新)。
 - `pre`**不是单独一个节点**，而是递归过程中**逐步串联起来的反转后链表的头节点**。
 - `reverse`函数运行过程(以`1->2->3->None`为例)：
   ```python
      1.判断cur!=None,不触发终止条件。
      2.令temp=cur.next(防止后续丢节点)。
      3.cur.next=pre
      4.cur=temp
   ```
 - 用`if`而非`while`是由递归的执行逻辑决定的，核心是利用递归的隐式循环替代`while`的显性循坏。
    - 递归的本质是"隐式循坏",不断调用自身，直到触发终止条件(即，每次调用`self.reverse(temp,cur)`就相当于`while`循坏里的"迭代步骤")。
    - 递归法里的参数变化步骤(以`1->2->3->None`为例)：
       - 初步调用：`reverse(1,None)`。   已反转：`1->None`   未反转：`2->3->None`   #**两链表处于分开未连接状态**
       - 第二次调用：`reverse(2,1)`。其中当前处理参数为`cur=2`，`pre=1`(下一个需要处理的节点和反转之后需要指向的节点)。   已反转：`2->1->None`   未反转：`3->None`
       - 第三次调用：`reverse(3,2)`。   已反转：`3->2->1`   未反转：`None`
       - 第四次调用：`reverse(None,3)`。   已反转：`None->3->2->1`
       - **回溯返回结果**：后续所有递归回溯，每一层都直接把`3`传上去(`3`是反转链表的唯一头节点。第三次递归调整完`3.next=2`后，接受到最深处返回的`3`，再把`2`传给第二次递归...),最终返回值都是`3`。
         ```markdown
            回溯过程 (关键)
            第四次返回：返回 3
            第三次 return self.reverse(None, 3) → 返回 3
            第二次 return self.reverse(3, 2) → 返回 3
            第一次 return self.reverse(2, 1) → 返回 3
         ```
 - `return self.reverse(temp,cur)`:这样表示能一直推进下去，直到链表走到`None`。下一次要处理的节点是`temp=cur.next`(未处理部分),反转后当前的节点`cur`就成了下一次递归的`pre`。
